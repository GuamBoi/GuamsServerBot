import discord
import random

TOKEN = 'YOUR_DISCORD_BOT_TOKEN'
QUESTION_FILE = 'trivia_questions.txt'  # Path to your trivia questions file
DELIMITER = ','  # Delimiter used to separate question, correct answer, and options

client = discord.Client()

# Load trivia questions from the text file
def load_questions(filename):
    questions = []
    with open(filename, 'r') as file:
        for line in file:
            question_data = line.strip().split(DELIMITER)
            if len(question_data) >= 4:  # Ensure there's at least a question, correct answer, and one option
                question = question_data[0]
                correct_answer = question_data[1]
                options = question_data[1:]
                random.shuffle(options)
                questions.append((question, correct_answer, options))
    return questions

questions = load_questions(QUESTION_FILE)

# Dictionary to store game states for each channel
game_states = {}

@client.event
async def on_ready():
    print('Logged in as', client.user.name)

@client.event
async def on_message(message):
    if message.author == client.user:
        return

    if message.content.startswith('!trivia start'):
        if message.channel.id in game_states:
            await message.channel.send("A trivia game is already in progress in this channel!")
            return

        # Start a new game
        random.shuffle(questions)
        game_states[message.channel.id] = {
            'questions': iter(questions),
            'scoreboard': {}
        }
        await ask_question(message.channel)

    elif message.content.startswith('!trivia stop'):
        if message.channel.id not in game_states:
            await message.channel.send("No trivia game is currently in progress in this channel!")
            return

        del game_states[message.channel.id]
        await message.channel.send("Trivia game stopped.")

    elif message.content.startswith('!trivia leaderboard'):
        if message.channel.id not in game_states:
            await message.channel.send("No trivia game is currently in progress in this channel!")
            return

        leaderboard = sorted(game_states[message.channel.id]['scoreboard'].items(), key=lambda x: x[1], reverse=True)
        if not leaderboard:
            await message.channel.send("No one has scored yet!")
            return

        leaderboard_msg = "Leaderboard:\n"
        for i, (user_id, score) in enumerate(leaderboard, start=1):
            user = message.guild.get_member(user_id)
            if user:
                leaderboard_msg += f"{i}. {user.display_name}: {score}\n"
            else:
                leaderboard_msg += f"{i}. User not found: {score}\n"

        await message.channel.send(leaderboard_msg)

async def ask_question(channel):
    state = game_states[channel.id]
    try:
        question, correct_answer, options = next(state['questions'])
    except StopIteration:
        del game_states[channel.id]
        await channel.send("No more questions! Game over.")
        return

    await channel.send(question)
    for i, option in enumerate(options, start=1):
        await channel.send(f"{i}. {option}")

    def check(m):
        return m.channel == channel and m.author != client.user

    try:
        response = await client.wait_for('message', check=check, timeout=30)
    except asyncio.TimeoutError:
        await channel.send("Time's up! The correct answer was: " + correct_answer)
    else:
        try:
            choice = int(response.content) - 1
            if options[choice] == correct_answer:
                await channel.send(f"Correct, {response.author.display_name}!")
                state['scoreboard'][response.author.id] = state['scoreboard'].get(response.author.id, 0) + 1
            else:
                await channel.send(f"Sorry, {response.author.display_name}, the correct answer was: {correct_answer}")
        except (ValueError, IndexError):
            await channel.send("Invalid choice! Try again.")
        await ask_question(channel)

client.run(TOKEN)
